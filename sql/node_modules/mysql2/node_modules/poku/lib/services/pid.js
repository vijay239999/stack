"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPIDs = exports.killPID = exports.populateRange = exports.setPortsAndPIDs = void 0;
const node_child_process_1 = require("child_process");
const regex = {
    sequentialSpaces: /\s+/,
};
const setPortsAndPIDs = (portOrPID) => Array.isArray(portOrPID)
    ? portOrPID
    : [portOrPID].map((p) => Number(p)).filter((p) => !Number.isNaN(p));
exports.setPortsAndPIDs = setPortsAndPIDs;
const populateRange = (startsAt, endsAt) => {
    const first = Number(startsAt);
    const last = Number(endsAt);
    return Array.from({ length: last - first + 1 }, (_, i) => first + i);
};
exports.populateRange = populateRange;
exports.killPID = {
    unix: (PID) => new Promise((resolve) => {
        const service = (0, node_child_process_1.spawn)('kill', ['-9', String(Number(PID))]);
        service.on('close', () => resolve(undefined));
    }),
    windows: (PID) => new Promise((resolve) => {
        const service = (0, node_child_process_1.spawn)('taskkill', [
            '/F',
            '/T',
            '/PID',
            String(Number(PID)),
        ]);
        service.on('close', () => resolve(undefined));
    }),
};
exports.getPIDs = {
    unix: (port) => new Promise((resolve) => {
        const PIDs = new Set();
        const service = (0, node_child_process_1.spawn)('lsof', [
            '-t',
            '-i',
            `:${Number(port)}`,
            '-s',
            'TCP:LISTEN',
        ]);
        service.stdout.on('data', (data) => {
            const output = data.toString().trim().split('\n');
            for (const pid of output) {
                if (pid)
                    PIDs.add(Number(pid));
            }
        });
        service.on('close', () => resolve(Array.from(PIDs)));
    }),
    windows: (port) => new Promise((resolve) => {
        const PIDs = new Set();
        const service = (0, node_child_process_1.spawn)('cmd.exe', [
            '/c',
            `netstat -aon | findstr :${Number(port)}`,
        ]);
        service.stdout.on('data', (data) => {
            const output = data.toString().trim();
            const lines = output.trim().split('\n');
            lines.map((line) => {
                const tokens = line.trim().split(regex.sequentialSpaces);
                const stateIndex = tokens.indexOf('LISTENING');
                if (stateIndex !== -1 && tokens[stateIndex + 1]) {
                    const pid = Number(tokens[stateIndex + 1]);
                    if (!Number.isNaN(pid))
                        PIDs.add(pid);
                }
            });
        });
        service.on('close', () => resolve(Array.from(PIDs)));
    }),
};
