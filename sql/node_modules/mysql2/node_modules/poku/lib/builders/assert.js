"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAssert = void 0;
const assert_js_1 = require("../services/assert.js");
const createAssert = (nodeAssert) => {
    const ok = (value, message) => (0, assert_js_1.processAssert)(() => nodeAssert.ok(value), { message });
    const equal = (actual, expected, message) => {
        (0, assert_js_1.processAssert)(() => nodeAssert.equal(actual, expected), { message });
    };
    const deepEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.deepEqual(actual, expected), { message });
    const strictEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.strictEqual(actual, expected), { message });
    const deepStrictEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.deepStrictEqual(actual, expected), {
        message,
    });
    const notEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.notEqual(actual, expected), {
        message,
    });
    const notDeepEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.notDeepEqual(actual, expected), { message });
    const notStrictEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.notStrictEqual(actual, expected), {
        message,
    });
    const notDeepStrictEqual = (actual, expected, message) => (0, assert_js_1.processAssert)(() => nodeAssert.notDeepStrictEqual(actual, expected), {
        message,
    });
    const ifError = (value, message) => (0, assert_js_1.processAssert)(() => nodeAssert.ifError(value), {
        message,
        defaultMessage: 'Expected no error, but received an error',
        hideDiff: true,
        throw: true,
    });
    const fail = (message) => {
        (0, assert_js_1.processAssert)(() => nodeAssert.fail(message), {
            message,
            defaultMessage: 'Test failed intentionally',
            hideDiff: true,
        });
        process.exit(1);
    };
    function doesNotThrow(block, errorOrMessage, message) {
        (0, assert_js_1.processAssert)(() => {
            if (typeof errorOrMessage === 'function' ||
                errorOrMessage instanceof RegExp ||
                typeof errorOrMessage === 'object')
                nodeAssert.doesNotThrow(block, errorOrMessage, message);
            else {
                const msg = typeof errorOrMessage === 'string' ? errorOrMessage : message;
                nodeAssert.doesNotThrow(block, msg);
            }
        }, {
            message: typeof errorOrMessage === 'string' ? errorOrMessage : message,
            defaultMessage: 'Expected function not to throw',
            hideDiff: true,
            throw: true,
        });
    }
    function throws(block, errorOrMessage, message) {
        if (typeof errorOrMessage === 'function' ||
            errorOrMessage instanceof RegExp ||
            typeof errorOrMessage === 'object')
            (0, assert_js_1.processAssert)(() => nodeAssert.throws(block, errorOrMessage), {
                message,
                defaultMessage: 'Expected function to throw',
                hideDiff: true,
            });
        else {
            const msg = typeof errorOrMessage !== 'undefined' ? errorOrMessage : message;
            (0, assert_js_1.processAssert)(() => nodeAssert.throws(block, message), {
                message: msg,
                defaultMessage: 'Expected function to throw',
                hideDiff: true,
            });
        }
    }
    async function rejects(block, errorOrMessage, message) {
        await (0, assert_js_1.processAsyncAssert)(async () => {
            if (typeof errorOrMessage === 'function' ||
                errorOrMessage instanceof RegExp ||
                typeof errorOrMessage === 'object')
                await nodeAssert.rejects(block, errorOrMessage, message);
            else {
                const msg = typeof errorOrMessage === 'string' ? errorOrMessage : message;
                await nodeAssert.rejects(block, msg);
            }
        }, {
            message: typeof errorOrMessage === 'string' ? errorOrMessage : message,
            defaultMessage: 'Expected promise to be rejected with specified error',
            hideDiff: true,
            throw: true,
        });
    }
    async function doesNotReject(block, errorOrMessage, message) {
        await (0, assert_js_1.processAsyncAssert)(async () => {
            if (typeof errorOrMessage === 'function' ||
                errorOrMessage instanceof RegExp ||
                typeof errorOrMessage === 'object')
                await nodeAssert.doesNotReject(block, errorOrMessage, message);
            else
                await nodeAssert.doesNotReject(block, message);
        }, {
            message: typeof errorOrMessage === 'string' ? errorOrMessage : message,
            defaultMessage: 'Got unwanted rejection',
            hideDiff: true,
            throw: true,
        });
    }
    const match = (value, regExp, message) => {
        (0, assert_js_1.processAssert)(() => nodeAssert?.match(value, regExp), {
            message,
            actual: 'Value',
            expected: 'RegExp',
            defaultMessage: 'Value should match regExp',
        });
    };
    const doesNotMatch = (value, regExp, message) => {
        (0, assert_js_1.processAssert)(() => nodeAssert.doesNotMatch(value, regExp), {
            message,
            actual: 'Value',
            expected: 'RegExp',
            defaultMessage: 'Value should not match regExp',
        });
    };
    const assert = Object.assign((value, message) => ok(value, message), {
        ok,
        equal,
        deepEqual,
        strictEqual,
        deepStrictEqual,
        doesNotMatch,
        doesNotReject,
        throws,
        doesNotThrow,
        notEqual,
        notDeepEqual,
        notStrictEqual,
        notDeepStrictEqual,
        match,
        ifError,
        fail,
        rejects,
    });
    return assert;
};
exports.createAssert = createAssert;
