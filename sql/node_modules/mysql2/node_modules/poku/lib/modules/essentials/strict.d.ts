export declare const strict: ((value: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void) & {
    ok: (value: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    equal: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    deepEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    strictEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    deepStrictEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    doesNotMatch: (value: string, regExp: RegExp, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    doesNotReject: {
        (block: (() => Promise<unknown>) | Promise<unknown>, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): Promise<void>;
        (block: (() => Promise<unknown>) | Promise<unknown>, error: import("assert").AssertPredicate, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): Promise<void>;
    };
    throws: {
        (block: () => unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): void;
        (block: () => unknown, error: import("assert").AssertPredicate, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): void;
    };
    doesNotThrow: {
        (block: () => unknown, message?: string | import("../../@types/assert.js").ProcessAssertionOptions["message"]): void;
        (block: () => unknown, error: import("assert").AssertPredicate, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): void;
    };
    notEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    notDeepEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    notStrictEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    notDeepStrictEqual: (actual: unknown, expected: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    match: (value: string, regExp: RegExp, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    ifError: (value: unknown, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => void;
    fail: (message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]) => never;
    rejects: {
        (block: (() => Promise<unknown>) | Promise<unknown>, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): Promise<void>;
        (block: (() => Promise<unknown>) | Promise<unknown>, error: import("assert").AssertPredicate, message?: import("../../@types/assert.js").ProcessAssertionOptions["message"]): Promise<void>;
    };
};
